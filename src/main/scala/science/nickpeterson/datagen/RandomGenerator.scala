package science.nickpeterson.datagen

import shapeless._
import shapeless.ops.nat.ToInt


/** Typeclass for objects that can be randomly generated.
  *
  * @param run Function used to produce a random value (and a RandomnessSource with updated seed) from a source
  * @tparam A Type of object to be generated
  */
case class RandomGenerator[A](run: RandomnessSource => (RandomnessSource, A)) {

  /** Monadic sequencing for RandomGenerator instances.
    *
    * Provide a method for choosing a new RandomGenerator, given the outcome of THIS RandomGenerator.
    *
    * @param f Method for choosing new RandomGenerator based on the output of this one
    * @tparam B Type of the newly created RandomGenerator instance
    * @return New RandomGenerator that represents choosing an A, then using that A (and the function f) to pick a
    *         RandomGenerator[B]
    */
  def flatMap[B](f: A => RandomGenerator[B]): RandomGenerator[B] = RandomGenerator { src =>
    val (src2, a) = run(src)
    f(a).run(src2)
  }

  /** Return a new RandomGenerator, representing the result of applying a transformation to the outcome of this one.
    *
    * @param f Transformation to be applied
    * @tparam B Codomain of f
    * @return New RandomGenerator, which chooses an A according to this one and then applies the function f.
    */
  def map[B](f: A => B): RandomGenerator[B] = flatMap { a => RandomGenerator.const(f(a)) }
}

object RandomGenerator extends RandomGeneratorLowPriority {

  /** Random generator that always returns the input value (a).
    *
    * This is the "pure" operation for the RandomGenerator monad.
    *
    * @param a Value the new degenerate RandomGenerator should alwyas return
    * @tparam A Type of a
    * @return Degenerate RandomGenerator that always returns the value a.
    */
  def const[A](a: A): RandomGenerator[A] = RandomGenerator {src => (src, a)}

  /** Return a new RandomGenerator which chooses sequences of fixed length, each coordinate chosen by this generator.
    *
    * @param gen Generator to sequence
    * @param n Length of the sequences to generate
    * @tparam A Type generated by gen
    * @return RandomGenerator that chooses sequences of length n using gen
    */
  def repeat[A](gen: RandomGenerator[A], n: Int): RandomGenerator[List[A]] = {
    (1 to n).toList.foldRight(const(List.empty[A])) {(_, cur) =>
      for { h <- gen; t <- cur} yield h :: t
    }
  }

  /** Helper method to get implicit RandomGenerator instances. */
  def apply[A](implicit gen: RandomGenerator[A]): RandomGenerator[A] = gen

  /** RandomGenerator for Ints representing random bits. Base for other generators. */
  def bitGenerator(n: Int): RandomGenerator[Int] = RandomGenerator { src => src.getBits(n) }
}

trait RandomGeneratorLowPriority extends RandomGeneratorDerived {

  /** Generator for full (32-bit) integers. */
  implicit val intGenerator: RandomGenerator[Int] = RandomGenerator.bitGenerator(32)

  /** Generator for random Long values, by generating random ints for the first 32 bits and last 32 bits. */
  implicit val longGenerator: RandomGenerator[Long] = for {
    bigBits <- intGenerator
    smallBits <- intGenerator
  } yield { (bigBits.asInstanceOf[Long] << 32) + smallBits}

  /** Generator for random Float values. */
  implicit val floatGenerator: RandomGenerator[Float] = for {
    bits <- RandomGenerator.bitGenerator(24)
  } yield {bits / (1 << 24).asInstanceOf[Float]}

  /** Generator for random Double values. Values are output in range [0, 1]. */
  implicit val doubleGenerator: RandomGenerator[Double] = for {
    bigBits <- RandomGenerator.bitGenerator(26) map { _.asInstanceOf[Long] << 27 }
    smallBits <- RandomGenerator.bitGenerator(27)
  } yield {(bigBits + smallBits) / (1L << 53).asInstanceOf[Double]}

  /** Generator for random 16-bit characters. */
  implicit val charGenerator: RandomGenerator[Char] = RandomGenerator.bitGenerator(16) map { _.toChar }

  /** Generator for random Boolean values. */
  implicit val boolGenerator: RandomGenerator[Boolean] = RandomGenerator.bitGenerator(1).map {_ != 0}

  /** Generator for singleton types.  Degenerate -- always returns the only possible value. */
  implicit def singletonGenerator[A](implicit witness: Witness.Aux[A]): RandomGenerator[A] = {
    RandomGenerator.const(witness.value)
  }
}

trait RandomGeneratorDerived {
  /** Generator for products of arity 1, in which the single type has a known generator. */
  implicit def productBase[A](implicit gen: RandomGenerator[A]): RandomGenerator[A :: HNil] = gen map { _ :: HNil }

  /** Generator for coproducts of arity 1, in which the single type has a known generator. */
  implicit def coproductBase[A](implicit gen: RandomGenerator[A]): RandomGenerator[A :+: CNil] = gen map { Inl(_) }

  /** Generator for any type isomorphic to another type with a known generator. */
  implicit def genericGen[C, H](implicit
    isomorphism: Generic.Aux[C, H],
    gen: RandomGenerator[H]
  ): RandomGenerator[C] = gen.map {h => isomorphism.from(h)}

  /** Recursive step for building generators for product types. */
  implicit def hListRecurse[H, T <: HList](implicit
    hGen: RandomGenerator[H],
    tGen: RandomGenerator[T]
  ): RandomGenerator[H :: T] = for { h <- hGen; t <- tGen} yield {h :: t}

  /** Recursive step for building generators for coproduct types. */
  implicit def coproductRecurse[A, B <: Coproduct, N <: Nat](implicit
    firstGen: RandomGenerator[A],
    restGen: RandomGenerator[B],
    tailSizeWitness: CoproductSize.Aux[B, N],
    tailSize: ToInt[N]
  ): RandomGenerator[A :+: B] = RandomGenerator {src =>
    val (src2, p) = RandomGenerator.doubleGenerator.run(src)
    val cutoff = 1.0 / (tailSize() + 1)

    if (p <= cutoff) firstGen.run(src2) match { case (src3, v) => (src3, Inl(v))}
    else restGen.run(src2) match { case (src3, v) => (src3, Inr(v))}
  }
}